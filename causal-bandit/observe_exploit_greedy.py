from numpy import *
import matplotlib.pyplot as plt

N1 = 7
N2 = 1
qub = ones(N1)
qb = ones(N2)*1/2.0
q = hstack((qb,qub))
print q
q2 = q**2
mq2 = (1-q)**2
N = q.shape[0]

ta1 = ones(q.shape)
ta0 = ones(q.shape)
#ta0[0]=10

# its far from clear that this greedy approach must lead to the optimal solution
#- and unusual things clearly happend - ie discontinuities in derivative for common arm
# possibly these things may be numerical.

#sum_ca = zeros(len(q)) # stores sum_ca for i != a for each i=1...N


A = 0.01
h = 800

t0 = zeros(h)
t1 = zeros(h)
mincost = zeros(h)

def calculate_sum_ca(q2,mq2,ta1,ta0):
    ca = ta0*ta1/(ta1*mq2+ta0*q2)
    result = nansum(ca)
    if isnan(result):
        return 0 # this will be default anyway from numpy 1.9
    return result
    

def cost(q2,mq2,ta1,ta0):
    sum_ca = calculate_sum_ca(q2,mq2,ta1,ta0)
    partA = sum(exp(-A*(ta1+q2*sum_ca)))
    partB = sum(exp(-A*(ta0+mq2*sum_ca)))
    #print partA,partB
    return partA+partB
                                   

current_cost = cost(q2,mq2,ta1,ta0)
for step in range(h):
    best_drop = 0
    action = (-1,-1)
    #print ta1
    for i in range(q.shape[0]):
        ta1[i] += 1
        
        c = cost(q2,mq2,ta1,ta0)
        drop = current_cost - c
     #   print ta1,drop
        if drop > best_drop:
            best_drop = drop
            action = (1,i)
        ta1[i] -=1
        

    for i in range(q.shape[0]):
        ta0[i] += 1
        c = cost(q2,mq2,ta1,ta0)
        drop = current_cost - c
      #  print ta0,drop
        if drop > best_drop:
            best_drop = drop
            action = (0,i)
        ta0[i] -=1

    #print action
    if action[0] == 1:
        ta1[action[1]]+=1
    else:
        ta0[action[1]]+=1
    current_cost -= best_drop
    mincost[step] = current_cost

    t0[step] = ta0[1] # rare
    t1[step] = ta1[0] # common
print "-----------GREEDY----------"
print ta0
print ta1
print sum(ta0)+sum(ta1)
print cost(q2,mq2,ta1,ta0)
print "--------------------------"

hvals = arange(h)
analytic = ((N2+1)*(hvals+2*N)/float((N2+1)*N1+4*N2) - 4*N2*log((N2+1)*(2*N2+1)/float(4*N2))/float(A*((N2+1)*N1+4*N2))) # note use of integer division to round result to integer ...
analytic = fmax(0,analytic)
analytic_ta1 = (((hvals+2*N) - N1*analytic)/float(2.0*N2)) 
acost = zeros(h)


for step in range(h):
    ata0 = ones(q.shape)
    ata0[0:N2]*=int(analytic_ta1[step])
    ata0[N2:]*= int(analytic[step])
    ata1 = zeros(q.shape)
    ata1[0:N2] = int(analytic_ta1[step])
    c = cost(q2,mq2,ata1,ata0)
    acost[step] = c
    #print ata0
    #print ata1
    #print c
print "-----------ANALYTIC--------"
print ata0
print ata1
print sum(ata0)+sum(ata1)
print cost(q2,mq2,ata1,ata0)
print "---------------------------"

fig,axes = plt.subplots(2,1)
axes[0].plot(hvals,t0,label = "greedy-rare")
#axes[0].plot(hvals,t1,label = "greedy-common")
axes[0].plot(hvals,analytic,label="analytic-rare")
#axes[0].plot(hvals,analytic_ta1,label="analytic-common")
axes[0].set_xlabel("time step")
axes[0].set_ylabel("number of pulls")
axes[0].legend(loc="lower right",numpoints=1)
axes[1].plot(hvals,log(mincost),label="greedy")
axes[1].plot(hvals,log(acost),label="analytic")
axes[1].set_xlabel("time step")
axes[1].set_ylabel("log of error bound")
axes[1].legend(loc="upper right",numpoints=1)

plt.show()
            
        
        
    
